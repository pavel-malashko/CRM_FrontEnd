{"remainingRequest":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular\\material\\esm5\\expansion.es5.js","dependencies":[{"path":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular\\material\\esm5\\expansion.es5.js","mtime":499162500000},{"path":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_core,_angular_animations,tslib,_angular_cdk_accordion,_angular_cdk_coercion,_angular_cdk_collections,_angular_cdk_portal,_angular_common,_angular_platform_browser_animations,rxjs,rxjs_operators,_angular_cdk_a11y,_angular_cdk_keycodes PURE_IMPORTS_END */\nimport { InjectionToken, Directive, TemplateRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, EventEmitter, ElementRef, Input, Inject, Optional, Output, SkipSelf, ViewContainerRef, ViewEncapsulation, ViewChild, Host, ContentChildren, NgModule } from '@angular/core';\nimport { animate, animateChild, group, state, style, transition, trigger, query } from '@angular/animations';\nimport { __extends } from 'tslib';\nimport { CdkAccordionItem, CdkAccordion, CdkAccordionModule } from '@angular/cdk/accordion';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { Subject, merge, Subscription, EMPTY } from 'rxjs';\nimport { filter, startWith, take, distinctUntilChanged } from 'rxjs/operators';\nimport { FocusMonitor, FocusKeyManager } from '@angular/cdk/a11y';\nimport { ENTER, SPACE, HOME, END } from '@angular/cdk/keycodes';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Token used to provide a `MatAccordion` to `MatExpansionPanel`.\n * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.\n  @type {?} */\nvar MAT_ACCORDION = /*@__PURE__*/ new InjectionToken('MAT_ACCORDION');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Time and timing curve for expansion panel animations.\n  @type {?} */\nvar EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';\n/** *\n * Animations used by the Material expansion panel.\n *\n * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()\n * causes the animation state of moved components to become `void` upon exit, and not update again\n * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state\n * of the panel is `expanded` or `collapsed` but the animation state is `void`.\n *\n * To correctly handle animating to the next state, we animate between `void` and `collapsed` which\n * are defined to have the same styles. Since angular animates from the current styles to the\n * destination state's style definition, in situations where we are moving from `void`'s styles to\n * `collapsed` this acts a noop since no style values change.\n *\n * In the case where angular's animation state is out of sync with the expansion panel's state, the\n * expansion panel being `expanded` and angular animations being `void`, the animation from the\n * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will\n * occur as expected.\n *\n * Angular Bug: https://github.com/angular/angular/issues/18847\n *\n * \\@docs-private\n  @type {?} */\nvar matExpansionAnimations = {\n    /** Animation that rotates the indicator arrow. */\n    indicatorRotate: /*@__PURE__*/ trigger('indicatorRotate', [\n        /*@__PURE__*/ state('collapsed, void', /*@__PURE__*/ style({ transform: 'rotate(0deg)' })),\n        /*@__PURE__*/ state('expanded', /*@__PURE__*/ style({ transform: 'rotate(180deg)' })),\n        /*@__PURE__*/ transition('expanded <=> collapsed, void => collapsed', /*@__PURE__*/ animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n    ]),\n    /** Animation that expands and collapses the panel header height. */\n    expansionHeaderHeight: /*@__PURE__*/ trigger('expansionHeight', [\n        /*@__PURE__*/ state('collapsed, void', /*@__PURE__*/ style({\n            height: '{{collapsedHeight}}',\n        }), {\n            params: { collapsedHeight: '48px' },\n        }),\n        /*@__PURE__*/ state('expanded', /*@__PURE__*/ style({\n            height: '{{expandedHeight}}'\n        }), {\n            params: { expandedHeight: '64px' }\n        }),\n        /*@__PURE__*/ transition('expanded <=> collapsed, void => collapsed', /*@__PURE__*/ group([\n            /*@__PURE__*/ query('@indicatorRotate', /*@__PURE__*/ animateChild(), { optional: true }),\n            /*@__PURE__*/ animate(EXPANSION_PANEL_ANIMATION_TIMING),\n        ])),\n    ]),\n    /** Animation that expands and collapses the panel content. */\n    bodyExpansion: /*@__PURE__*/ trigger('bodyExpansion', [\n        /*@__PURE__*/ state('collapsed, void', /*@__PURE__*/ style({ height: '0px', visibility: 'hidden' })),\n        /*@__PURE__*/ state('expanded', /*@__PURE__*/ style({ height: '*', visibility: 'visible' })),\n        /*@__PURE__*/ transition('expanded <=> collapsed, void => collapsed', /*@__PURE__*/ animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n    ])\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Expansion panel content that will be rendered lazily\n * after the panel is opened for the first time.\n */\nvar MatExpansionPanelContent = /** @class */ /*@__PURE__*/ (function () {\n    function MatExpansionPanelContent(_template) {\n        this._template = _template;\n    }\n    return MatExpansionPanelContent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Counter for generating unique element ids.\n  @type {?} */\nvar uniqueId = 0;\nvar Éµ0 = undefined;\n/**\n * `<mat-expansion-panel>`\n *\n * This component can be used as a single element to show expandable content, or as one of\n * multiple children of an element with the MatAccordion directive attached.\n */\nvar MatExpansionPanel = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(MatExpansionPanel, _super);\n    function MatExpansionPanel(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, \n    // @breaking-change 8.0.0 _document and _animationMode to be made required\n    _document, _animationMode) {\n        var _this = _super.call(this, accordion, _changeDetectorRef, _uniqueSelectionDispatcher) || this;\n        _this._viewContainerRef = _viewContainerRef;\n        _this._animationMode = _animationMode;\n        _this._hideToggle = false;\n        /**\n         * An event emitted after the body's expansion animation happens.\n         */\n        _this.afterExpand = new EventEmitter();\n        /**\n         * An event emitted after the body's collapse animation happens.\n         */\n        _this.afterCollapse = new EventEmitter();\n        /**\n         * Stream that emits for changes in `\\@Input` properties.\n         */\n        _this._inputChanges = new Subject();\n        /**\n         * ID for the associated header element. Used for a11y labelling.\n         */\n        _this._headerId = \"mat-expansion-panel-header-\" + uniqueId++;\n        /**\n         * Stream of body animation done events.\n         */\n        _this._bodyAnimationDone = new Subject();\n        _this.accordion = accordion;\n        _this._document = _document;\n        // We need a Subject with distinctUntilChanged, because the `done` event\n        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\n        _this._bodyAnimationDone.pipe(distinctUntilChanged(function (x, y) {\n            return x.fromState === y.fromState && x.toState === y.toState;\n        })).subscribe(function (event) {\n            if (event.fromState !== 'void') {\n                if (event.toState === 'expanded') {\n                    _this.afterExpand.emit();\n                }\n                else if (event.toState === 'collapsed') {\n                    _this.afterCollapse.emit();\n                }\n            }\n        });\n        return _this;\n    }\n    Object.defineProperty(MatExpansionPanel.prototype, \"hideToggle\", {\n        /** Whether the toggle indicator should be hidden. */\n        get: /**\n         * Whether the toggle indicator should be hidden.\n         * @return {?}\n         */ function () {\n            return this._hideToggle || (this.accordion && this.accordion.hideToggle);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._hideToggle = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Determines whether the expansion panel should have spacing between it and its siblings. */\n    /**\n     * Determines whether the expansion panel should have spacing between it and its siblings.\n     * @return {?}\n     */\n    MatExpansionPanel.prototype._hasSpacing = /**\n     * Determines whether the expansion panel should have spacing between it and its siblings.\n     * @return {?}\n     */\n        function () {\n            if (this.accordion) {\n                // We don't need to subscribe to the `stateChanges` of the parent accordion because each time\n                // the [displayMode] input changes, the change detection will also cover the host bindings\n                // of this expansion panel.\n                return (this.expanded ? this.accordion.displayMode : this._getExpandedState()) === 'default';\n            }\n            return false;\n        };\n    /** Gets the expanded state string. */\n    /**\n     * Gets the expanded state string.\n     * @return {?}\n     */\n    MatExpansionPanel.prototype._getExpandedState = /**\n     * Gets the expanded state string.\n     * @return {?}\n     */\n        function () {\n            return this.expanded ? 'expanded' : 'collapsed';\n        };\n    /**\n     * @return {?}\n     */\n    MatExpansionPanel.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._lazyContent) {\n                // Render the content as soon as the panel becomes open.\n                this.opened.pipe(startWith(/** @type {?} */ ((null))), filter(function () { return _this.expanded && !_this._portal; }), take(1)).subscribe(function () {\n                    _this._portal = new TemplatePortal(_this._lazyContent._template, _this._viewContainerRef);\n                });\n            }\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MatExpansionPanel.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            this._inputChanges.next(changes);\n        };\n    /**\n     * @return {?}\n     */\n    MatExpansionPanel.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            _super.prototype.ngOnDestroy.call(this);\n            this._bodyAnimationDone.complete();\n            this._inputChanges.complete();\n        };\n    /** Checks whether the expansion panel's content contains the currently-focused element. */\n    /**\n     * Checks whether the expansion panel's content contains the currently-focused element.\n     * @return {?}\n     */\n    MatExpansionPanel.prototype._containsFocus = /**\n     * Checks whether the expansion panel's content contains the currently-focused element.\n     * @return {?}\n     */\n        function () {\n            if (this._body && this._document) {\n                /** @type {?} */\n                var focusedElement = this._document.activeElement;\n                /** @type {?} */\n                var bodyElement = this._body.nativeElement;\n                return focusedElement === bodyElement || bodyElement.contains(focusedElement);\n            }\n            return false;\n        };\n    return MatExpansionPanel;\n}(CdkAccordionItem));\nvar MatExpansionPanelActionRow = /** @class */ /*@__PURE__*/ (function () {\n    function MatExpansionPanelActionRow() {\n    }\n    return MatExpansionPanelActionRow;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * `<mat-expansion-panel-header>`\n *\n * This component corresponds to the header element of an `<mat-expansion-panel>`.\n */\nvar MatExpansionPanelHeader = /** @class */ /*@__PURE__*/ (function () {\n    function MatExpansionPanelHeader(panel, _element, _focusMonitor, _changeDetectorRef) {\n        var _this = this;\n        this.panel = panel;\n        this._element = _element;\n        this._focusMonitor = _focusMonitor;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._parentChangeSubscription = Subscription.EMPTY;\n        /** @type {?} */\n        var accordionHideToggleChange = panel.accordion ?\n            panel.accordion._stateChanges.pipe(filter(function (changes) { return !!changes[\"hideToggle\"]; })) : EMPTY;\n        // Since the toggle state depends on an @Input on the panel, we\n        // need to subscribe and trigger change detection manually.\n        this._parentChangeSubscription = merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(filter(function (changes) { return !!(changes[\"hideToggle\"] || changes[\"disabled\"]); })))\n            .subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n        // Avoids focus being lost if the panel contained the focused element and was closed.\n        panel.closed\n            .pipe(filter(function () { return panel._containsFocus(); }))\n            .subscribe(function () { return _focusMonitor.focusVia(_element, 'program'); });\n        _focusMonitor.monitor(_element).subscribe(function (origin) {\n            if (origin && panel.accordion) {\n                panel.accordion._handleHeaderFocus(_this);\n            }\n        });\n    }\n    Object.defineProperty(MatExpansionPanelHeader.prototype, \"disabled\", {\n        /**\n         * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.\n         * @docs-private\n         */\n        get: /**\n         * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.\n         * \\@docs-private\n         * @return {?}\n         */ function () {\n            return this.panel.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Toggles the expanded state of the panel. */\n    /**\n     * Toggles the expanded state of the panel.\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype._toggle = /**\n     * Toggles the expanded state of the panel.\n     * @return {?}\n     */\n        function () {\n            this.panel.toggle();\n        };\n    /** Gets whether the panel is expanded. */\n    /**\n     * Gets whether the panel is expanded.\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype._isExpanded = /**\n     * Gets whether the panel is expanded.\n     * @return {?}\n     */\n        function () {\n            return this.panel.expanded;\n        };\n    /** Gets the expanded state string of the panel. */\n    /**\n     * Gets the expanded state string of the panel.\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype._getExpandedState = /**\n     * Gets the expanded state string of the panel.\n     * @return {?}\n     */\n        function () {\n            return this.panel._getExpandedState();\n        };\n    /** Gets the panel id. */\n    /**\n     * Gets the panel id.\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype._getPanelId = /**\n     * Gets the panel id.\n     * @return {?}\n     */\n        function () {\n            return this.panel.id;\n        };\n    /** Gets whether the expand indicator should be shown. */\n    /**\n     * Gets whether the expand indicator should be shown.\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype._showToggle = /**\n     * Gets whether the expand indicator should be shown.\n     * @return {?}\n     */\n        function () {\n            return !this.panel.hideToggle && !this.panel.disabled;\n        };\n    /** Handle keydown event calling to toggle() if appropriate. */\n    /**\n     * Handle keydown event calling to toggle() if appropriate.\n     * @param {?} event\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype._keydown = /**\n     * Handle keydown event calling to toggle() if appropriate.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            switch (event.keyCode) {\n                // Toggle for space and enter keys.\n                case SPACE:\n                case ENTER:\n                    if (!event.altKey && !event.metaKey && !event.shiftKey && !event.ctrlKey) {\n                        event.preventDefault();\n                        this._toggle();\n                    }\n                    break;\n                default:\n                    if (this.panel.accordion) {\n                        this.panel.accordion._handleHeaderKeydown(event);\n                    }\n                    return;\n            }\n        };\n    /**\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\n     * @param origin Origin of the action that triggered the focus.\n     * @docs-private\n     */\n    /**\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\n     * \\@docs-private\n     * @param {?=} origin Origin of the action that triggered the focus.\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype.focus = /**\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\n     * \\@docs-private\n     * @param {?=} origin Origin of the action that triggered the focus.\n     * @return {?}\n     */\n        function (origin) {\n            if (origin === void 0) {\n                origin = 'program';\n            }\n            this._focusMonitor.focusVia(this._element, origin);\n        };\n    /**\n     * @return {?}\n     */\n    MatExpansionPanelHeader.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._parentChangeSubscription.unsubscribe();\n            this._focusMonitor.stopMonitoring(this._element);\n        };\n    return MatExpansionPanelHeader;\n}());\n/**\n * `<mat-panel-description>`\n *\n * This directive is to be used inside of the MatExpansionPanelHeader component.\n */\nvar MatExpansionPanelDescription = /** @class */ /*@__PURE__*/ (function () {\n    function MatExpansionPanelDescription() {\n    }\n    return MatExpansionPanelDescription;\n}());\n/**\n * `<mat-panel-title>`\n *\n * This directive is to be used inside of the MatExpansionPanelHeader component.\n */\nvar MatExpansionPanelTitle = /** @class */ /*@__PURE__*/ (function () {\n    function MatExpansionPanelTitle() {\n    }\n    return MatExpansionPanelTitle;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Directive for a Material Design Accordion.\n */\nvar MatAccordion = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(MatAccordion, _super);\n    function MatAccordion() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._hideToggle = false;\n        /**\n         * Display mode used for all expansion panels in the accordion. Currently two display\n         * modes exist:\n         *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded\n         *     panel at a different elevation from the rest of the accordion.\n         *  flat - no spacing is placed around expanded panels, showing all panels at the same\n         *     elevation.\n         */\n        _this.displayMode = 'default';\n        return _this;\n    }\n    Object.defineProperty(MatAccordion.prototype, \"hideToggle\", {\n        /** Whether the expansion indicator should be hidden. */\n        get: /**\n         * Whether the expansion indicator should be hidden.\n         * @return {?}\n         */ function () { return this._hideToggle; },\n        set: /**\n         * @param {?} show\n         * @return {?}\n         */ function (show) { this._hideToggle = coerceBooleanProperty(show); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatAccordion.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._keyManager = new FocusKeyManager(this._headers).withWrap();\n        };\n    /** Handles keyboard events coming in from the panel headers. */\n    /**\n     * Handles keyboard events coming in from the panel headers.\n     * @param {?} event\n     * @return {?}\n     */\n    MatAccordion.prototype._handleHeaderKeydown = /**\n     * Handles keyboard events coming in from the panel headers.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var keyCode = event.keyCode;\n            /** @type {?} */\n            var manager = this._keyManager;\n            if (keyCode === HOME) {\n                manager.setFirstItemActive();\n                event.preventDefault();\n            }\n            else if (keyCode === END) {\n                manager.setLastItemActive();\n                event.preventDefault();\n            }\n            else {\n                this._keyManager.onKeydown(event);\n            }\n        };\n    /**\n     * @param {?} header\n     * @return {?}\n     */\n    MatAccordion.prototype._handleHeaderFocus = /**\n     * @param {?} header\n     * @return {?}\n     */\n        function (header) {\n            this._keyManager.updateActiveItem(header);\n        };\n    return MatAccordion;\n}(CdkAccordion));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MatExpansionModule = /** @class */ /*@__PURE__*/ (function () {\n    function MatExpansionModule() {\n    }\n    return MatExpansionModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nexport { MatExpansionModule, MatAccordion, MAT_ACCORDION, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelDescription, MatExpansionPanelTitle, MatExpansionPanelContent, EXPANSION_PANEL_ANIMATION_TIMING, matExpansionAnimations };\n//# sourceMappingURL=expansion.es5.js.map\n",null]}