{"remainingRequest":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular\\material\\esm5\\slide-toggle.es5.js","dependencies":[{"path":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular\\material\\esm5\\slide-toggle.es5.js","mtime":499162500000},{"path":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Chief Accountant\\Desktop\\frontPTS\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_core,tslib,_angular_cdk_a11y,_angular_cdk_bidi,_angular_cdk_coercion,_angular_cdk_platform,_angular_forms,_angular_material_core,_angular_platform_browser_animations,_angular_cdk_observers,_angular_platform_browser PURE_IMPORTS_END */\nimport { InjectionToken, Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, forwardRef, Input, Output, ViewChild, ViewEncapsulation, NgZone, Optional, Inject, NgModule } from '@angular/core';\nimport { __extends } from 'tslib';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { mixinColor, mixinDisabled, mixinDisableRipple, mixinTabIndex, GestureConfig, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token to be used to override the default options for `mat-slide-toggle`.\n  @type {?} */\nvar MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = /*@__PURE__*/ new InjectionToken('mat-slide-toggle-default-options', {\n    providedIn: 'root',\n    factory: function () { return ({ disableToggleValue: false, disableDragValue: false }); }\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar nextUniqueId = 0;\n/** *\n * \\@docs-private\n  @type {?} */\nvar MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MatSlideToggle; }),\n    multi: true\n};\n/**\n * Change event object emitted by a MatSlideToggle.\n */\nvar /**\n * Change event object emitted by a MatSlideToggle.\n */ MatSlideToggleChange = /** @class */ /*@__PURE__*/ (function () {\n    function MatSlideToggleChange(source, checked) {\n        this.source = source;\n        this.checked = checked;\n    }\n    return MatSlideToggleChange;\n}());\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatSlideToggleBase = /** @class */ /*@__PURE__*/ (function () {\n    function MatSlideToggleBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatSlideToggleBase;\n}());\n/** @type {?} */\nvar _MatSlideToggleMixinBase = /*@__PURE__*/ mixinTabIndex(/*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinDisabled(MatSlideToggleBase)), 'accent'));\n/**\n * Represents a slidable \"switch\" toggle that can be moved between on and off.\n */\nvar MatSlideToggle = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(MatSlideToggle, _super);\n    function MatSlideToggle(elementRef, /**\n                   * @deprecated The `_platform` parameter to be removed.\n                   * @breaking-change 8.0.0\n                   */ _platform, _focusMonitor, _changeDetectorRef, tabIndex, _ngZone, defaults, _animationMode, _dir) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._focusMonitor = _focusMonitor;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._ngZone = _ngZone;\n        _this.defaults = defaults;\n        _this._animationMode = _animationMode;\n        _this._dir = _dir;\n        _this.onChange = function (_) { };\n        _this.onTouched = function () { };\n        _this._uniqueId = \"mat-slide-toggle-\" + ++nextUniqueId;\n        _this._required = false;\n        _this._checked = false;\n        /**\n         * Whether the thumb is currently being dragged.\n         */\n        _this._dragging = false;\n        /**\n         * Name value will be applied to the input element if present.\n         */\n        _this.name = null;\n        /**\n         * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.\n         */\n        _this.id = _this._uniqueId;\n        /**\n         * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.\n         */\n        _this.labelPosition = 'after';\n        /**\n         * Used to set the aria-label attribute on the underlying input element.\n         */\n        _this.ariaLabel = null;\n        /**\n         * Used to set the aria-labelledby attribute on the underlying input element.\n         */\n        _this.ariaLabelledby = null;\n        /**\n         * An event will be dispatched each time the slide-toggle changes its value.\n         */\n        _this.change = new EventEmitter();\n        /**\n         * An event will be dispatched each time the slide-toggle input is toggled.\n         * This event is always emitted when the user toggles the slide toggle, but this does not mean\n         * the slide toggle's value has changed. The event does not fire when the user drags to change\n         * the slide toggle value.\n         */\n        _this.toggleChange = new EventEmitter();\n        /**\n         * An event will be dispatched each time the slide-toggle is dragged.\n         * This event is always emitted when the user drags the slide toggle to make a change greater\n         * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when\n         * the user toggles the slide toggle to change its value.\n         */\n        _this.dragChange = new EventEmitter();\n        _this.tabIndex = parseInt(tabIndex) || 0;\n        return _this;\n    }\n    Object.defineProperty(MatSlideToggle.prototype, \"required\", {\n        /** Whether the slide-toggle is required. */\n        get: /**\n         * Whether the slide-toggle is required.\n         * @return {?}\n         */ function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._required = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlideToggle.prototype, \"checked\", {\n        /** Whether the slide-toggle element is checked or not. */\n        get: /**\n         * Whether the slide-toggle element is checked or not.\n         * @return {?}\n         */ function () { return this._checked; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._checked = coerceBooleanProperty(value);\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlideToggle.prototype, \"inputId\", {\n        /** Returns the unique id for the visual hidden input. */\n        get: /**\n         * Returns the unique id for the visual hidden input.\n         * @return {?}\n         */ function () { return (this.id || this._uniqueId) + \"-input\"; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatSlideToggle.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._focusMonitor\n                .monitor(this._elementRef, true)\n                .subscribe(function (focusOrigin) {\n                if (!focusOrigin) {\n                    // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n                    // Angular does not expect events to be raised during change detection, so any state\n                    // change (such as a form control's 'ng-touched') will cause a changed-after-checked\n                    // error. See https://github.com/angular/angular/issues/17793. To work around this,\n                    // we defer telling the form control it has been touched until the next tick.\n                    Promise.resolve().then(function () { return _this.onTouched(); });\n                }\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MatSlideToggle.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        };\n    /** Method being called whenever the underlying input emits a change event. */\n    /**\n     * Method being called whenever the underlying input emits a change event.\n     * @param {?} event\n     * @return {?}\n     */\n    MatSlideToggle.prototype._onChangeEvent = /**\n     * Method being called whenever the underlying input emits a change event.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // We always have to stop propagation on the change event.\n            // Otherwise the change event, from the input element, will bubble up and\n            // emit its event object to the component's `change` output.\n            event.stopPropagation();\n            if (!this._dragging) {\n                this.toggleChange.emit();\n            }\n            // Releasing the pointer over the `<label>` element while dragging triggers another\n            // click event on the `<label>` element. This means that the checked state of the underlying\n            // input changed unintentionally and needs to be changed back. Or when the slide toggle's config\n            // disabled toggle change event by setting `disableToggleValue: true`, the slide toggle's value\n            // does not change, and the checked state of the underlying input needs to be changed back.\n            if (this._dragging || this.defaults.disableToggleValue) {\n                this._inputElement.nativeElement.checked = this.checked;\n                return;\n            }\n            // Sync the value from the underlying input element with the component instance.\n            this.checked = this._inputElement.nativeElement.checked;\n            // Emit our custom change event only if the underlying input emitted one. This ensures that\n            // there is no change event, when the checked state changes programmatically.\n            this._emitChangeEvent();\n        };\n    /** Method being called whenever the slide-toggle has been clicked. */\n    /**\n     * Method being called whenever the slide-toggle has been clicked.\n     * @param {?} event\n     * @return {?}\n     */\n    MatSlideToggle.prototype._onInputClick = /**\n     * Method being called whenever the slide-toggle has been clicked.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // We have to stop propagation for click events on the visual hidden input element.\n            // By default, when a user clicks on a label element, a generated click event will be\n            // dispatched on the associated input element. Since we are using a label element as our\n            // root container, the click event on the `slide-toggle` will be executed twice.\n            // The real click event will bubble up, and the generated click event also tries to bubble up.\n            // This will lead to multiple click events.\n            // Preventing bubbling for the second event will solve that issue.\n            event.stopPropagation();\n        };\n    /** Implemented as part of ControlValueAccessor. */\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n    MatSlideToggle.prototype.writeValue = /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.checked = !!value;\n        };\n    /** Implemented as part of ControlValueAccessor. */\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n    MatSlideToggle.prototype.registerOnChange = /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onChange = fn;\n        };\n    /** Implemented as part of ControlValueAccessor. */\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n    MatSlideToggle.prototype.registerOnTouched = /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onTouched = fn;\n        };\n    /** Implemented as a part of ControlValueAccessor. */\n    /**\n     * Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    MatSlideToggle.prototype.setDisabledState = /**\n     * Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            this.disabled = isDisabled;\n            this._changeDetectorRef.markForCheck();\n        };\n    /** Focuses the slide-toggle. */\n    /**\n     * Focuses the slide-toggle.\n     * @return {?}\n     */\n    MatSlideToggle.prototype.focus = /**\n     * Focuses the slide-toggle.\n     * @return {?}\n     */\n        function () {\n            this._focusMonitor.focusVia(this._inputElement, 'keyboard');\n        };\n    /** Toggles the checked state of the slide-toggle. */\n    /**\n     * Toggles the checked state of the slide-toggle.\n     * @return {?}\n     */\n    MatSlideToggle.prototype.toggle = /**\n     * Toggles the checked state of the slide-toggle.\n     * @return {?}\n     */\n        function () {\n            this.checked = !this.checked;\n            this.onChange(this.checked);\n        };\n    /**\n     * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n     * @return {?}\n     */\n    MatSlideToggle.prototype._emitChangeEvent = /**\n     * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n     * @return {?}\n     */\n        function () {\n            this.onChange(this.checked);\n            this.change.emit(new MatSlideToggleChange(this, this.checked));\n        };\n    /**\n     * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.\n     * @param {?} distance\n     * @return {?}\n     */\n    MatSlideToggle.prototype._getDragPercentage = /**\n     * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.\n     * @param {?} distance\n     * @return {?}\n     */\n        function (distance) {\n            /** @type {?} */\n            var percentage = (distance / this._thumbBarWidth) * 100;\n            // When the toggle was initially checked, then we have to start the drag at the end.\n            if (this._previousChecked) {\n                percentage += 100;\n            }\n            return Math.max(0, Math.min(percentage, 100));\n        };\n    /**\n     * @return {?}\n     */\n    MatSlideToggle.prototype._onDragStart = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.disabled && !this._dragging) {\n                /** @type {?} */\n                var thumbEl = this._thumbEl.nativeElement;\n                this._thumbBarWidth = this._thumbBarEl.nativeElement.clientWidth - thumbEl.clientWidth;\n                thumbEl.classList.add('mat-dragging');\n                this._previousChecked = this.checked;\n                this._dragging = true;\n            }\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatSlideToggle.prototype._onDrag = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this._dragging) {\n                /** @type {?} */\n                var direction = this._dir && this._dir.value === 'rtl' ? -1 : 1;\n                this._dragPercentage = this._getDragPercentage(event.deltaX * direction);\n                /** @type {?} */\n                var dragX = (this._dragPercentage / 100) * this._thumbBarWidth * direction;\n                this._thumbEl.nativeElement.style.transform = \"translate3d(\" + dragX + \"px, 0, 0)\";\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatSlideToggle.prototype._onDragEnd = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._dragging) {\n                /** @type {?} */\n                var newCheckedValue = this._dragPercentage > 50;\n                if (newCheckedValue !== this.checked) {\n                    this.dragChange.emit();\n                    if (!this.defaults.disableDragValue) {\n                        this.checked = newCheckedValue;\n                        this._emitChangeEvent();\n                    }\n                }\n                // The drag should be stopped outside of the current event handler, otherwise the\n                // click event will be fired before it and will revert the drag change.\n                this._ngZone.runOutsideAngular(function () {\n                    return setTimeout(function () {\n                        if (_this._dragging) {\n                            _this._dragging = false;\n                            _this._thumbEl.nativeElement.classList.remove('mat-dragging');\n                            // Reset the transform because the component will take care\n                            // of the thumb position after drag.\n                            _this._thumbEl.nativeElement.style.transform = '';\n                        }\n                    });\n                });\n            }\n        };\n    /** Method being called whenever the label text changes. */\n    /**\n     * Method being called whenever the label text changes.\n     * @return {?}\n     */\n    MatSlideToggle.prototype._onLabelTextChange = /**\n     * Method being called whenever the label text changes.\n     * @return {?}\n     */\n        function () {\n            // Since the event of the `cdkObserveContent` directive runs outside of the zone, the\n            // slide-toggle component will be only marked for check, but no actual change detection runs\n            // automatically. Instead of going back into the zone in order to trigger a change detection\n            // which causes *all* components to be checked (if explicitly marked or not using OnPush),\n            // we only trigger an explicit change detection for the slide-toggle view and it's children.\n            this._changeDetectorRef.detectChanges();\n        };\n    return MatSlideToggle;\n}(_MatSlideToggleMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MatSlideToggleModule = /** @class */ /*@__PURE__*/ (function () {\n    function MatSlideToggleModule() {\n    }\n    return MatSlideToggleModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nexport { MatSlideToggleModule, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggleChange, MatSlideToggleBase, _MatSlideToggleMixinBase, MatSlideToggle, MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS };\n//# sourceMappingURL=slide-toggle.es5.js.map\n",null]}